# 객체 지향 체조 원칙 

객체지향 생활 체조 원칙은 추상적인 가이드가 아니라 구체적인 가이드를 제시하고 있다.

## 1. 한 메서드에 오직 한 단계의 들여 쓰기만 한다.

각 메서드가 정확히 한 가지 일을 하는지, 즉 메서드 당 하나의 제어 구조나 하나의 문장 단락으로 되어 있는지를 지키려고 노력한다. 

**한 메서드 안에 중첩된 제어 구조가 있다면 다단계의 추상화를 코드로 짠 것이며, 고로 한 가지 이상의 일을 하고 있다는 뜻이다.**

```java
// Before
class Board {  
   //...   
   String board() {    
      StringBuffer buf = new StringBuffer();    
      for (int i = 0; i < 10; i++) {      
         for (int j = 0; j < 10; j++)         
            buf.append(data[i][j]);      
         buf.append("\n");
      }
      return buf.toString();
   }
}
// After
class Board {
   //   ...   
   String board() {      
      StringBuffer buf = new StringBuffer();      
      collectRows(buf);      
      return buf.toString();   
   }   
   
   void collectRows(StringBuffer buf) {      
      for (int i = 0; i < 10; i++) {         
         collectRow(buf, i);      
      }   
   }   
   
   void collectRow(StringBuffer buf, int row) {      
      for (int i = 0; i < 10; i++) {         
         buf.append(data[row][i]);         
         buf.append("\n");      
      }   
   }
}
```

이렇게 더 적어진 코드에서 버그의 존재를 판별하기란 대체로 훨씬 쉽다.

---

## 2. else 예약어를 쓰지 않는다.

**리팩터링보다는 그냥 기존 조건문에 분기를 하나 더 치기가 무척 쉽다.**

**조건문은 곧잘 복제의 원흉이기도 하다.**

return 문을 일찍 쓰는 것을 너무 많이 하면 간결함을 저해하기 쉽다는 점을 간과해서는 안된다.

객체지향 언어는 다형성이라는 강력한 도구를 통해 복잡한 조건문을 처리할 수 있다. 간단한 경우라면 보호절(guard clause)과 조기 반환(early return)으로 대체 가능하다.

```java
// Before (if-else 문의 사용은 자제하자)
public static void endMe() {  
	if (status === DONE) {    
      doSomething();  
   } else {
      <other code>
   }
}

// After	(else 제거)
public static void endMe() {  
   if (status === DONE) {    
      doSomething();    
      return;  
   }  
   <other code>
}

// Before (return이 너무 반복된다)
public static Node head() {  
   if (isAdvancing()) 
      return first;  
   else return last;
}

// After	(return 사용 감소)
public static Node head() {  
   return isAdvancing() ? first : last;}
```

---

## 3. 모든 원시값과 문자열을 포장한다.

- 원시형 변수로는 컴파일러가 의미적으로 맞는 프로그램 작성을 안내할 수 없다.
- 객체로라면 아주 사소하더라도 컴파일러와 프로그래머에게 그 값이 어떤 값이며, 왜 쓰고 있는지에 대한 정보를 전하는 셈이다.

---

## 4. 한 줄에 점을 하나만 찍는다

- **여러 개의 점이 들어 있는 코드 몇 줄을 들여다보기 시작하면, 책임 소재의 오류를 많이 발견하기 시작한다.**
- 어떠한 코드 한 줄에서라도 점이 하나 이상 있으면 그른 곳에서 동작이 일어나고 있다는 뜻이다.
- 디미터 법칙("친구하고만 대화하라")이 좋은 출발점이긴 하지만, 이런 식으로 생각하자.
  자기 소유의 장난감, 자기가 만든 장난감, 그리고 누군가 자기에게 준 장난감하고만 놀 수 있다. 하지만 절대 장난감의 장난감과 놀면 안된다.
- 메소드 이름은 이 멋진 신세계에서 주석의 자리를 대신하니, 자 이제 이름 짓기에 시간을 투자하자.

```java
// Before
class Board {
	//	...
	class Piece {
      // ...
      String representation;
   }
   
   class Location {
      // ...
      Piece current;
   }
   
   String boardRepresentation() {
      StringBuffer buf = new StringBuffer();
      for(Location l : squares())
         buf.append(l.current.representation.substring(0,1));
      return buf.toString();
   }
}

// After
class Board {
   // ...
   class Piece {
      // ...
      private STring representation;
      String character() {
         return representation.substring(0,1);
      }
      
      void addTo(StringBuffer buf){
         current.addTo(buf);
      }
   }
   
   String boardRepresentation() {
      StringBuffer buf = new StringBuffer();
      for(Location l : squares())
         l.addTo(buf);
      return buf.toString();
   }
}
```

---

## 5. 줄여쓰지 않는다. (축약금지)

- 클래스, 메서드, 또는 변수의 이름을 줄이려는 유혹에 곧잘 빠지곤 한다. 그런 유혹을 뿌리쳐라.
- 축약은 혼란을 야기하며, 더 큰 문제를 숨기는 경향이 있다.
- 클래스와 메서드 이름을 한두 단어로 유지하려고 노력하고 문맥을 중복하는 이름을 자제하자.
- 이 훈련을 위해 모든 엔티티는 한 두 단어로 된 이름을 축약없이 가져야 한다.
- **클래스 이름이 Order라면 shipOrder라고 메서드 이름을 지을 필요가 없다. 짧게 ship()이라고 하면 클라이언트에서는 order.ship()라고 호출하며, 간결한 호출의 표현이 된다.**

---

## 6. 모든 엔티티를 작게 유지한다.

- **이 말은 50줄 이상 되는 클래스와 10개 파일 이상되는 패키지는 없어야 한다는 뜻이다.**
- 50줄 이상의 클래스는 보통 한 가지 일 이상을 하는 것이며, 따라서 코드의 이해와 재사용을 점점 더 어렵게 끌고 간다.
- 클래스를 작게 작성할 때 난감한 경우는 같이 있어야 말이 되는 동작의 묶음이 있을 때다.
  이는 패키지를 최대한활용해야 하는 곳이기도 하다.
- 패키지도 클래스처럼 응집력 있고 단일한 목표가 있어야 한다.
- **패키지를 작게 유지하면 패키지 자체가 진정한 정체성을 지니게 된다**

---

## 7. 2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.

- 대부분의 클래스가 간단하게 하나의 상태 변수를 처리하는 일을 맡아야 마땅하지만, 몇몇 경우 둘이 필요할 때가 있다.
- 새로운 인스턴스 변수를 하나 더 기존 클래스에 추가하면 클래스의 응집도는 즉시 떨어진다.
- 많은 인스턴스 변수를 지니 클래스를 대상으로 응집력 있는 단일 작업을 설명할 수 있는 경우는 거의 없다.

> #### **인스턴스 변수**
>
> **인스턴스 변수는 인스턴스가 생성될 때 생성됩니다.** 그렇기 때문에 인스턴스 변수의 값을 읽어오거나 저장하려면 인스턴스를 먼저 생성해야합니다. 인스턴스 별로 다른 값을 가질 수 있으므로, 각각의 인스턴스마다 고유의 값을 가져야할 때는 인스턴스 변수로 선언합니다.
>
> #### **클래스 변수**
>
>  **클래스 변수는 인스턴스 변수에 static만 붙여주면 됩니다.** 인스턴스 변수는 각각 고유한 값을 가지지만 클래스 변수는 모든 인스턴스가 공통된 값을 공유하게 됩니다. 한 클래스의 모든 인스턴스들이 공통적인 값을 가져야할 때 클래스 변수로 선언합니다. 클래스가 로딩될 때 생성되어(그러므로 메모리에 딱 한번만 올라갑니다.) 종료 될 때 까지 유지되는 클래스 변수는 public 을 붙이면 같은 프로그램 내에서 어디서든 접근할 수 있는 전역 변수가 됩니다. 또한 인스턴스 변수의 접근법과 다르게 인스턴스를 생성하지 않고 클래스이름.클래스변수명 을 통해서 접근할 수 있습니다.
>
> #### **지역 변수**
>
>  **메서드 내에서 선언되며 메서드 내에서만 사용할 수 있는 변수입니다.** 메서드가 실행될 때 메모리를 할당 받으며 메서드가 끝나면 소멸되어 사용할 수 없게 됩니다.

---

## 8. First Class 콜렉션을 쓴다.

- 콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.
- 각 콜렉션은 그 자체로 포장돼 있으므로 이제 콜렉션과 관련된 동작은 근거지가 마련된 셈이다.
- 필터가 이 새 클래스의 일부가 됨을 알 수 있다. 필터는 또한 스스로 함수 객체가 될 수 있다. 또한 새 클래스는 두 그룹을 같이 묶는다든가 그룹의 각 원소에 규칙을 적용하는 등의 동작을 처리할 수 있다. 이는 인스턴스 변수에 대한 규칙의 확실한 확장이지만 그 자체를 위해서도 중요하다.
- 콜렉션은 실로 매우 유용한 원시 타입이다. 많은 동작이 있지만 후임 프로그래머나 유지보수 담당자에 의미적 의도나 단초는 거의 없다.

----

## 9. Getter/Setter/Property를 쓰지 않는다.

- 만약 객체가 지금 인스턴스 변수의 적당한 집합을 캡슐화 하고 있지만 그 설계가 여전히 어색하다면, 좀 더 직접적인 캡슐화 위반을 조사해볼 때다. 그냥 단순히 현재 위치에서의 값을 물을 수 있는 동작이라면 해당 인스턴스 변수를 제대로 따라가지 못할 것이다.
- 강한 캡슐화 경계의 바탕에 깔린 사상은 동작의 검색과 배치를 위해 남겨둔 코드를 만질 다른 프로그래머를 위해 객체 모델의 단일한 지점으로 유도하려는 것이다.
- 이는 많은 긍정적인 하부효과를 가져다 주는데, 중복 오류의 극적 축소와 새 기능의 구현을 위한 변경의 지역화 개선 등이 있다.
- 이 규칙은 흔히 "말을 해, 묻지 말고"라고 일컫는다.